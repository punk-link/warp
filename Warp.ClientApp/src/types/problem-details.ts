// Problem Details (RFC 7807-like) shape used by the frontend.
// Required fields: type, title, status, detail, traceId (note: server may send 'trace-id').
// Optional fields may include eventId, sentryId, stackTrace, errors (validation), plus any additional members.

export interface ProblemDetails {
    /** A URI reference that identifies the problem type. */
    type: string
    /** A short, human-readable summary of the problem type. */
    title: string
    /** The HTTP status code generated by the origin server. */
    status: number
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail: string
    /** Correlation / trace identifier (server original key 'trace-id'). */
    traceId: string

    /** Optional server event identifier (server key 'event-id'). */
    eventId?: number
    /** Optional Sentry identifier for error tracking (server key 'sentry-id'). */
    sentryId?: string
    /** Server stack trace (server key 'stack-trace'). */
    stackTrace?: string
    /** Validation / domain errors bag. Each property -> list of messages. */
    errors?: Record<string, string[]>

    /** Additional arbitrary extension members. */
    [extension: string]: unknown
}


export type ProblemDetailsLike = ProblemDetails // alias for clarity when partials not allowed yet


export function isProblemDetails(value: unknown): value is ProblemDetails {
    if (!value || typeof value !== 'object')
        return false

    const v: any = value
    return typeof v.type === 'string'
        && typeof v.title === 'string'
        && typeof v.status === 'number'
        && typeof v.detail === 'string'
        && typeof v.traceId === 'string'
}


function asString(v: unknown): string | undefined {
    if (v == null) 
        return undefined

    if (typeof v === 'string') 
        return v

    if (typeof v === 'number' || typeof v === 'boolean') 
        return String(v)

    return undefined
}


function asNumber(v: unknown): number | undefined {
    if (typeof v === 'number' && Number.isFinite(v)) 
        return v

    if (typeof v === 'string' && v.trim() !== '') {
        const n = Number(v)
        return Number.isFinite(n) ? n : undefined
    }

    return undefined
}


function normalizeErrors(raw: any): Record<string, string[]> | undefined {
    if (!raw || typeof raw !== 'object' || Array.isArray(raw)) 
        return undefined

    const result: Record<string, string[]> = {}
    for (const [k, v] of Object.entries(raw)) {
        if (Array.isArray(v)) {
            const arr = v.map(asString).filter((s): s is string => !!s)
            if (arr.length) 
                result[k] = arr
        } else {
            const s = asString(v)
            if (s) result[k] = [s]
        }
    }

    return Object.keys(result).length ? result : undefined
}


export class ProblemDetailsParseError extends Error {
    raw: unknown
    constructor(message: string, raw: unknown) {
        super(message)
        this.name = 'ProblemDetailsParseError'
        this.raw = raw
    }
}


export function toProblemDetails(raw: any): ProblemDetails {
    if (!raw || typeof raw !== 'object') 
        throw new ProblemDetailsParseError('Problem details payload is not an object', raw)

    const type = asString(raw.type)
    const title = asString(raw.title)
    const status = asNumber(raw.status)
    const detail = asString(raw.detail)
    const traceId = asString(raw.traceId ?? raw['trace-id'])

    if (!type || !title || status == null || !detail || !traceId) {
        const missing: string[] = []
        if (!type) missing.push('type')
        if (!title) missing.push('title')
        if (status == null) missing.push('status')
        if (!detail) missing.push('detail')
        if (!traceId) missing.push('traceId')
        throw new ProblemDetailsParseError(`Problem details missing required field(s): ${missing.join(', ')}`, raw)
    }

    const eventId = asNumber(raw.eventId ?? raw['event-id'])
    const sentryId = asString(raw.sentryId ?? raw['sentry-id'])
    const stackTrace = asString(raw.stackTrace ?? raw['stack-trace'])
    const errors = normalizeErrors(raw.errors)

    const base: ProblemDetails = {
        type,
        title,
        status,
        detail,
        traceId,
        ...(eventId != null ? { eventId } : {}),
        ...(sentryId ? { sentryId } : {}),
        ...(stackTrace ? { stackTrace } : {}),
        ...(errors ? { errors } : {})
    }

    for (const [k, v] of Object.entries(raw)) {
        if (k in base) 
            continue

        if (['trace-id', 'event-id', 'sentry-id', 'stack-trace', 'traceId', 'eventId', 'sentryId', 'stackTrace', 'errors', 'type', 'title', 'status', 'detail'].includes(k)) 
            continue

        (base as any)[k] = v
    }


    return base
}
