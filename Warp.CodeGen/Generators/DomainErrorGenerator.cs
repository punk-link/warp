using System.Text;
using Warp.CodeGen.Models;
using Warp.CodeGen.Utilities;

namespace Warp.CodeGen.Generators;

/// <summary>
/// Generates the DomainErrors.cs file containing static methods for creating DomainError instances
/// </summary>
public partial class DomainErrorGenerator : BaseGenerator
{
    public static void Generate(LoggingConfig loggingConfig, string outputFilePath)
    {
        Console.WriteLine($"Generating domain errors to {outputFilePath}");
        
        var sb = new StringBuilder();
        sb.AppendLine("/// <auto-generated/>");
        sb.AppendLine("// Generated on: " + DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss UTC"));
        sb.AppendLine("using Warp.WebApp.Constants.Logging;");
        sb.AppendLine();
        sb.AppendLine("#pragma warning disable IDE0130 // Namespace does not match folder structure");
        sb.AppendLine("namespace Warp.WebApp.Models.Errors;");
        sb.AppendLine("#pragma warning restore IDE0130 // Namespace does not match folder structure");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Provides static methods to create domain error instances");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class DomainErrors");
        sb.AppendLine("{");
        
        foreach (var category in loggingConfig.LoggingCategories)
        {
            var isLastCategory = category == loggingConfig.LoggingCategories.Last();
            
            if (!string.IsNullOrEmpty(category.Name))
                sb.AppendLine($"    // {category.Name}");
            
            foreach (var logEvent in category.Events)
            {
                if (logEvent.Obsolete)
                    sb.AppendLine($"    [Obsolete(\"This error is obsolete. Do not use.\")]");

                var description = logEvent.DomainErrorDescription ?? logEvent.Description;
                var methodParameters = ExtractParameters(description);
                var methodArguments = GetMethodArguments(description);
                
                // Convert named placeholders to indexed placeholders
                string indexedDescription = ConvertToIndexedFormat(description);
                
                sb.AppendLine($"    public static DomainError {logEvent.Name}({methodParameters})");
                
                if (!string.IsNullOrEmpty(description) && !string.IsNullOrEmpty(methodArguments))
                    sb.AppendLine($"        => new(LogEvents.{logEvent.Name}, string.Format(\"{indexedDescription}\", {methodArguments}));");
                else 
                    sb.AppendLine($"        => new(LogEvents.{logEvent.Name});");
                
                var isLastEventInCategory = logEvent == category.Events.Last();
                if (!isLastEventInCategory || !isLastCategory)
                    sb.AppendLine();
            }
            
            if (!isLastCategory && !string.IsNullOrEmpty(category.Name))
                sb.AppendLine();
        }
        
        sb.AppendLine("}");
        
        FileUtilities.WriteToFile(outputFilePath, sb.ToString());
    }
    
    /// <summary>
    /// Converts named format placeholders like {Name:type} to indexed format placeholders {0}, {1}, etc.
    /// </summary>
    /// <param name="formatString">The format string with named placeholders</param>
    /// <returns>A format string with indexed placeholders</returns>
    private static string ConvertToIndexedFormat(string? formatString)
    {
        if (string.IsNullOrEmpty(formatString))
            return string.Empty;
            
        var parameterIndices = new Dictionary<string, int>();
        int currentIndex = 0;
        
        return LogParametersRegex().Replace(formatString, match =>
        {
            var paramName = match.Groups[1].Value;
            if (paramName.Contains(':'))
            {
                var parts = paramName.Split(':');
                paramName = parts[0].Trim();
            }
            
            if (!parameterIndices.TryGetValue(paramName, out int index))
            {
                index = currentIndex++;
                parameterIndices[paramName] = index;
            }
            
            return "{" + index + "}";
        });
    }
}